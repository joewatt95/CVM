section ‹ TODO ›
theory Distinct_Elems_Analysis

imports
  CVM.Distinct_Elems_Algo
  CVM.Distinct_Elems_No_Fail
  CVM.Distinct_Elems_Eager
  CVM.Distinct_Elems_Binomial
  CVM.Utils_Real
  CVM.Utils_Concentration_Inequalities
  CVM.Utils_Reader_Monad_Hoare
  CVM.Utils_Reader_Monad_Relational

begin

locale with_threshold_and_eps = with_threshold +
  fixes ε :: real
  assumes eps_pos : ‹ε > 0›
begin

(* abbreviation (input) beyond_eps_range_of_card :: ‹'a list ⇒ nat ⇒ bool› where
  ‹beyond_eps_range_of_card xs n ≡ real n >[ε] card (set xs)› *)

(* Ideas on part of the proof for the big K (ie > l) part. *)

abbreviation
  ‹finite_state_chi _ state ≡ finite (state_chi state)›

abbreviation
  ‹same_states φ state φ' state' ≡
    finite_state_chi φ state ∧ φ = φ' ∧ state = state'›

lemma initial_state_well_formed :
  ‹finite_state_chi φ initial_state›
  by (simp add: initial_state_def) 

lemma eager_step_preserves_finiteness :
  fixes xs i
  defines [simp] : ‹P f ≡ ⊢rd ⟦finite_state_chi⟧ f xs i ⟦finite_state_chi⟧ ›
  shows ‹P step_1_eager› ‹P step_2_eager› ‹P eager_step›
proof -
  show ‹P step_1_eager› ‹P step_2_eager›
    unfolding step_1_eager_def step_2_eager_def
    by (auto
      intro!:
        Utils_Reader_Monad_Hoare.seq' Utils_Reader_Monad_Hoare.if_then_else Utils_Reader_Monad_Hoare.postcond_true
      simp add: Set.remove_def Let_def map_rd_def)

  then show ‹P eager_step›
    unfolding eager_step_def by (auto intro: Utils_Reader_Monad_Hoare.seq)
qed

context
  fixes xs :: ‹'a list›
begin

definition ‹ith_state i ≡ foldM_rd (eager_step (take i xs)) [0 ..< i]›

definition
  ‹ith_state_then_step_1 i ≡ ith_state i >=> step_1_eager (take (Suc i) xs) i›

lemma ith_state_zero_eq :
  ‹ith_state 0 = return_rd›
  by (auto simp add: ith_state_def)

context
  fixes
    i :: nat
  assumes i_lt_length_xs : ‹i < length xs›
begin

lemma ith_state_Suc_eq :
  ‹ith_state (Suc i) = (ith_state i >=> eager_step (take (Suc i) xs) i)›
  using i_lt_length_xs
  by (fastforce
    intro: arg_cong2[where f = bind_rd] foldM_cong eager_step_cong
    simp add: ith_state_def foldM_rd_snoc take_Suc_conv_app_nth)

lemma ith_state_preserves_same_states :
  defines
    [simp] : ‹P f ≡ ⊢rd ⟦same_states⟧ ⟨f i | f i⟩ ⟦same_states⟧› and
    [simp] : ‹eager_step' g j ≡ g (take (Suc j) xs) j›
  shows
    ‹P (eager_step' step_1_eager)›
    ‹P (eager_step' step_2_eager)›
    ‹P (eager_step' eager_step)›
    ‹P ith_state›
proof -
  show
    ‹P (eager_step' step_1_eager)›
    ‹P (eager_step' step_2_eager)›
    by (simp, smt (verit, best) Utils_Reader_Monad_Hoare.hoare_tripleE Utils_Reader_Monad_Relational.relational_hoare_triple_def eager_step_preserves_finiteness rel_rd_def)+

  then show ‹P (eager_step' eager_step)›
    unfolding eager_step_def by (auto intro: seq')

  then show ‹P ith_state›
    by (simp, smt (verit, ccfv_threshold) ith_state_def loop_unindexed Utils_Reader_Monad_Hoare.hoare_triple_def Utils_Reader_Monad_Relational.relational_hoare_triple_def eager_step_preserves_finiteness(3) rel_rd_def)
qed

lemma ith_state_k_increases_by_at_most_one :
  ‹⊢rd
    ⟦same_states⟧
    ⟨ith_state i | ith_state (Suc i)⟩
    ⟦(λ φ state φ' state'. state_k state' ≤ Suc (state_k state))⟧›
  (is ‹⊢rd ⟦_⟧ ⟨_ | _⟩ ⟦?S⟧›)
proof -
  note ith_state_preserves_same_states

  moreover have
    ‹⊢rd
      ⟦same_states φ state⟧
      step_1_eager xs i
      ⟦(λ _ state'. state_k state = state_k state')⟧›
    ‹⊢rd
      ⟦(λ _ state'. state_k state = state_k state')⟧
      step_2_eager xs i
      ⟦?S φ state⟧›
    for φ state i and xs :: ‹'a list›
    unfolding step_1_eager_def step_2_eager_def Let_def map_rd_def
    by (auto intro!: Utils_Reader_Monad_Hoare.seq' Utils_Reader_Monad_Hoare.if_then_else Utils_Reader_Monad_Hoare.postcond_true)

  ultimately show ?thesis
    by (auto
      intro!: skip_seq Utils_Reader_Monad_Hoare.seq
      simp add: ith_state_Suc_eq[unfolded eager_step_def])
qed

lemma threshold_exceeded_of_k_lt :
  ‹⊢rd
    ⟦same_states⟧
    ⟨ith_state_then_step_1 i | ith_state (Suc i)⟩
    ⟦(λ φ state φ' state'.
      state_k state < state_k state' ⟶
      card (state_chi state) ≥ threshold)⟧›
  using i_lt_length_xs
  apply (auto
    intro!:
      seq ith_state_preserves_same_states skip_seq if_then_else
      Utils_Reader_Monad_Hoare.seq' Utils_Reader_Monad_Hoare.postcond_true
    simp add:
      ith_state_then_step_1_def
      ith_state_Suc_eq[unfolded eager_step_def step_2_eager_def]
      Let_def map_rd_def)
  sorry

end

lemma
  fixes l coin_matrix
  assumes ‹⊢rd
    ⟦(λ φ state. φ = coin_matrix ∧ state = initial_state)⟧
    ith_state (length xs)
    ⟦(λ φ state. state_k state > l)⟧›
    (is ‹?P (length xs) (>)›)
  shows
    ‹∃ i < length xs. ⊢rd
      ⟦(λ φ state. φ = coin_matrix ∧ state = initial_state)⟧
      ith_state_then_step_1 i
      ⟦(λ φ state. state_k state = l ∧ card (state_chi state) ≥ threshold)⟧›
    (is ‹∃ i. ?Q i›)
proof (rule exI)
  text
    ‹`?P` is a predicate such that `?P i R` holds iff
    after running the algorithm for `i` iterations, `R k_i l`.›

  define j i where
    ‹j ≡ Min {j. j ≤ length xs ∧ ?P j (>)}› and
    ‹i ≡ j - 1›

  let ?are_initial_state = ‹λ φ state φ' state'.
    φ = coin_matrix ∧ φ = φ' ∧
    state = initial_state ∧ state = state'›

  text
    ‹First, we make some basic observations about `i` and `j`, most importantly
    that:
    - `j` is a well defined minimum, so that `?P j (>)`.
       In other words, `j` is the smallest n such that after running the algorithm
       for j iterations, `k_n > l`.
    - `i < j`›

  have ‹?P j (>)›
    by (metis (no_types, lifting) j_def Collect_empty_eq Min_in assms(1) finite_nat_set_iff_bounded_le less_or_eq_imp_le mem_Collect_eq)

  moreover have ‹j = (LEAST j. ?P j (>))›
    by (smt (verit, best) LeastI assms nle_le wellorder_Least_lemma(2) Least_Min dual_order.eq_iff finite_nat_set_iff_bounded_le j_def mem_Collect_eq)

  ultimately have ‹i < j›
    by (metis (mono_tags, lifting) i_def Utils_Reader_Monad_Hoare.skip bot_nat_0.not_eq_extremum diff_less initial_state_def ith_state_zero_eq less_zeroE simps(1) zero_less_one)

  then have [simp] : ‹j = Suc i› using i_def by linarith

  text
    ‹Next we show that this is the `i` that we want, ie that:
    1. `i < length xs`
    2. After iteration `i`, `k_i = l`
    3. After iteration `i` and then step 1 of iteration `j = i + 1`,
       `|X_j| >= threshold`.›

  have ‹i < length xs›
    using ‹i < j› ‹j = (LEAST j. ?P j (>))› assms wellorder_Least_lemma(2) by fastforce

  text
    ‹`k_i = l` after running for `i` iterations, because:
    1. `i < j`
    2. `j` is the smallest `n` such that `k_n > l` after running for `n` iterations.
    3. `k` can only increase by at most 1 after iteration `j = i + 1`.›
  moreover have ‹?P i (=)›
  proof -
    note ‹i < j› ‹j = (LEAST j. ?P j (>))› ‹?P j (>)›

    moreover have ‹⊢rd
      ⟦?are_initial_state⟧
      ⟨ith_state i | ith_state j⟩
      ⟦(λ φ state φ' state'. state_k state' ≤ Suc (state_k state))⟧›
      using ith_state_k_increases_by_at_most_one[OF ‹i < length xs›] initial_state_well_formed
      by (auto intro: precond_strengthen[where R' = same_states])

    ultimately show ?thesis
      apply (simp add: relational_hoare_triple_def Utils_Reader_Monad_Hoare.hoare_triple_def rel_rd_def)
      by (metis (no_types, lifting) dual_order.strict_trans1 less_Suc_eq not_less_Least)
  qed

  moreover have ‹⊢rd
    ⟦(λ φ state. φ = coin_matrix ∧ state = initial_state)⟧
    ith_state_then_step_1 i
    ⟦(λ φ state. card (state_chi state) ≥ threshold)⟧›
  proof -
    have ‹⊢rd
      ⟦?are_initial_state⟧
      ⟨ith_state_then_step_1 i | ith_state j⟩
      ⟦(λ φ state φ' state'. state_k state < state_k state')⟧›
      using ‹?P i (=)› ‹?P j (>)›
      by (auto simp add: ith_state_then_step_1_def step_1_eager_def Let_def relational_hoare_triple_def rel_rd_def Utils_Reader_Monad_Hoare.hoare_triple_def run_reader_simps)

    moreover have ‹⊢rd
      ⟦?are_initial_state⟧
      ⟨ith_state_then_step_1 i | ith_state j⟩
      ⟦(λ φ state φ' state'.
        state_k state < state_k state' ⟶
        card (state_chi state) ≥ threshold)⟧›
      using threshold_exceeded_of_k_lt[OF ‹i < length xs›] initial_state_well_formed
      by (auto intro: precond_strengthen[where R' = same_states])

    ultimately show ?thesis
      using initial_state_well_formed
      by (simp add: relational_hoare_triple_def Utils_Reader_Monad_Hoare.hoare_triple_def rel_rd_def run_reader_simps)
    qed

  ultimately show ‹?Q i›
    unfolding step_1_eager_def ith_state_then_step_1_def Let_def
    by (auto simp add: relational_hoare_triple_def rel_rd_def Utils_Reader_Monad_Hoare.hoare_triple_def run_reader_simps)
qed

end

end
